# Network
<br>

<details>
  <summary><b> TCP vs UDP </b></summary>
<br />

-----------------------
  
  ![다운로드 (2)](https://user-images.githubusercontent.com/67133692/190865035-9da884f4-4bcc-4eed-8e0e-0045a640a7d4.png)
  
  TCP와 UDP는 TCP/IP 모델과 OSI표준 모델의 전송계층에 해당된다.<br>
  전송계층은 송신자와 수신자를 연결하는 통신서비스를 제공하고 IP에 의 해 전달되는 패킷의 오류를 검사하며 재전송 요구 제어등을 담당하는 계층이다. <br>
  TCP와 UDP는 포트 번호를 이용하여 주소를 지정하고, 데이터 오류 검사를 위한 체크섬이 존재하는 공통점이 있다.<br>

  
+ TCP(Transmission Control Protocol)
    + 속도는 느리나 안전성과 신뢰성이 있다.  데이터를 확실하게 주고받고 싶을 때 사용한다.
    + 연결지향형 프로그램이며, 데이터 처리속도를 조절하여 수신자의 버퍼 오버플로우를 방지함(흐름제어)
    + 네트워크 내의 패킷 수가 많이 증가하지 않도록 방지 > 정보의 소통량이 과하면 패킷을 조금씩 전송(혼잡제어)
    + 전송이 양방향으로 동시에 일어날 수 있다(전이중 방식) /  각 연결이 2개의 종단점을 가지고있다(점대점 방식)
    + 전이중, 점대점방식으로 데이터 전송방식이 있으나 멀티태스킹이나 브로드캐스팅은 지원하지 않는다.
    + 일대일 통신을 주로 한다
  
+ IP
    + 동영상 서비스에서 주로 사용되며, 간단한 데이터를 빠른 속도로 저장한다.
    + 데이터를 받던지 안받던지 일방적으로 데이터를 보낸다.
    + 일대일,일대 다 다대다 통신을 지원한다
  
  ![다운로드 (1)](https://user-images.githubusercontent.com/67133692/190865141-97daa0d5-082e-4d44-9e08-298b89cc0c8d.jpeg)

  
    

</details>

-----------------------

<br>

<details>
  <summary><b> 3-way handshaking </b></summary>
<br />

-----------------------
  
3-way handshaking는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 <br/>
데이터를 전송하기 전 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.<br/>

  
    

</details>

-----------------------

<br>

<details>
  <summary><b> HTTP vs HTTPS </b></summary>
<br />

-----------------------

+ HTTP
  + HTTP는 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.
  + 즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, 80포트를 사용하고 있다.
  + HTTP서버는 80포트에서 요청을 기다리고, 클라이언트는 80포트로 요청을 보낸다.
  + HTTP는 암호화가 되지 않는 평문 데이터를 전송하는 프로토콜이기 때문에 제3자가 정보를 조회할 수 있다.

+ HTTPS
  + HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다.
  + HTTPS는 HTTP와 다르게 443번 포트를 사용하며, 네트워크상에서 제3자가 정보를 볼 수 없도록 암호화를 지원한다

</details>

-----------------------

<br>

<details>
  <summary><b> HTTP 1.1 </b></summary>
<br />

-----------------------

  + 커넥션 유지 (Persistent Connection)
  + 호스트 헤더 (Host Header)
  + 강력한 인증 절차 (Improved Authentication Procedure)

</details>

-----------------------

<br>

<details>
  <summary><b> Port vs Sokect </b></summary>
<br />

-----------------------

+ Port
  + 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값
  + 하나의 IP 주소 내에 개별적으로 부여된 통신 프로세스
  
+ Sokect
  + 네트워크상에서 동작하는 프로그램 간 통신의 종착점(EndPoint)
  + 두 시스템 사이의 네트워크 연결을 나타내는 객체
  + 소켓을 열기 위해선 호스트에 할당된 IP, 포트 번호, 프로토콜이 필요하다.
  + 위 세가지로 소켓을 정의할 수 있ㄴ지만 유일하게 식별하지는 않는다.
  + 보내고 받는 쪽 모두 소켓을 열어야 한다.
  + 하나의 프로세스가 같은 포트를 갖고 여러 개의 소켓을 열 수 있다.


</details>

-----------------------

<br>

<details>
  <summary><b> HTTP Method </b></summary>
<br />

-----------------------

+ GET
  + 조회, 리소스 요청
  
+ POST
  + 요청된 데이터 처리
  + 자원 생성

+ PUT
  + 요청된 자원이 없으면 생성
  + 요청된 자원을 새 것으로 전체 갱신
  
+ PATCH
  + 자원의 일부분만 수정
  
+ DELETE
  + 요청된 자원 삭제
  
</details>

-----------------------

<br>

<details>
  <summary><b> CORS </b></summary>
<br />

-----------------------

+ CORS는 Cross-Origin Resource Sharing의 약자
+ 다른 출처의 자원을 공유하는것
+ 교차 출처 리소스 공유는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 어플리케이션이 다른 출처의 선택한 자원에<br/>
+ 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 것
  
  
+ CORS 해결 방법
  + 프론트 프록시 서버 설정
    + 프론트 서버에서 백엔드 서버로 요청을 보낼 때, 대상의 URL을 변경한다.
  + 직접 헤더 설정
    + 직접 헤더에 설정을 추가한다.
  + 스프링부트 설정
    + 설정 클래스를 만들고 WebMVCConfigure를 구현하면 addCorsMappings란 메서드를 사용하여 CORS의 출처 및 설정 관리를 할 수 있다.
  
</details>

-----------------------

<br>

<details>
  <summary><b> REST API </b></summary>
<br />

-----------------------

+ REST는 HTTP URI를 통해 자원을 명시 <Br/>
  HTTP Method를 통해 자원을 처리하도록 설계된 아키텍처 <Br/>
  REST를 기반으로 만든 API => REST API <Br/>
  RESTful은 REST 아키텍처를 구현하는 웹서비스를 나타내는 것으로 REST원리를 따르는 시스템을 RESTful이라고 함 <Br/>
  Hateoas는 REST API를 사용하는 클라이언트가 전적으로 서버와 동적인 상호작용이 가능하도록 하는것 <Br/>
  모든 관련된 동작을 URI를 통해 알려주고 클라이언트가 API의 변화에 일일이 대응하지 않아도 되는 장점 <Br/>
  HTTP를 기반으로 동작하여 HTTP의 이점을 그대로 가져올 수 있음
  
 
+ REST이 아닌것
  + HTTP Method를 한가지만 사용하고 있음
  + URL에 동사를 사용하고 있음 (리소스는 명사적 특성!)

✔️ HTTP의 자원을 제대로 활용하지 않고 있다면 REST하다고 할 수 없음
  
</details>

-----------------------

<br>

<details>
  <summary><b> JWT(Json Web Token) </b></summary>
<br />

-----------------------

+ JSON 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Toekn <Br/>
  토큰자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달 <Br/>
  토큰을 만들어 발행하기 때문에 쿠키에 담거나 HTTP 헤더에 담아서 보낼 수 있다. <Br/>
  따로 서버에 저장하지 않기 때문에 토큰이 유효한지 검증하는 과정이 필요하다. <Br/>
  악의적으로 탈취를 할 수 있기 대문에 유효시간을 짧게 하고 Refresh토큰을 사용하는 방식으로 구현해야함 <Br/>
  쿠키는 웹브라우저에서 사용할 수 있는 기능이므로 모바일 애플리케이션에서는 JWT를 사용한 인증방식이 최적임 <Br/> 
</details>

-----------------------

<br>

<details>
  <summary><b> OAuth </b></summary>
<br />

-----------------------

+ 자신이 소유한 리소스에 소프트웨어 애플리케이션이 접근할 수 있도록 허용해 줌으로써 접근 권한을 위임해주는 개방형 표준 프로토콜 
</details>

-----------------------


<br>

<details>
  <summary><b> URI </b></summary>
<br />

-----------------------
 
+ URI는 인터넷 자원을 식별하기 위한 문자열이다. <br>
URI는 인터넷 주소 같은 것으로 정보 리소스를 유일하게 식별하고 위치를 지정할 수 있다.<br>
URI의 하위개념으로 URL, URN이 있다.<br>
</details>

-----------------------


<br>

<details>
  <summary><b> URL </b></summary>
<br />

-----------------------

+ 웹에서 자원의 위치를 나타낸다, 특정 서버의 한 리소스에 대해 구체적인 위치를 표현한다. <br/>
 ex) http://www.pickafood.com/food/salad.jpg
</details>

-----------------------
<br>

<details>
  <summary><b> URN </b></summary>
<br />

-----------------------

+ 하나의 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 역할을 한다. <br/>
리소스를 여기저기로 옮기더라도 문제없이 동작한다.
</details>

-----------------------

<br>

<details>
  <summary><b> Route vs  Routing  vs Router </b></summary>
<br />

-----------------------

+ Route
  + 경로<br/>
+ Routing
  + 목적에 따라 통신데이터를 보낼때 최적의 경로를 선택하는 과정
+ Router
  + 인터넷 공유기! 하나의 인터넷 회신을 여러개의 네트워크가 사용할 수 있도록 쪼개주는 중계역할 장치

</details>

-----------------------

<br>

<details>
  <summary><b> IP </b></summary>
<br />

-----------------------

+ 인터넷에 연결되어 있는 장치(컴퓨터, 스마트폰, 태플릿 등) 각각의 장치를 식별할 수 있는 주소를 가지고 있는 것
</details>

-----------------------

<br>

<details>
  <summary><b> 도메인 </b></summary>
<br />

-----------------------

+ 각각의 IP에 이름을 부여하는 것
</details>

-----------------------
